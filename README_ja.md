# GeohashPy

GeohashPy は，Geohash の機能を Python によって包括的に実装したパッケージです．  
このパッケージは，地理座標を簡潔な文字列形式にエンコードおよびデコードするための Geohash アルゴリズムを主要なテーマとしています．なお，本プロジェクトは，[このブログ記事](http://mtcn.ko-me.com/%E9%96%A2%E6%95%B0%E3%80%81%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA/geohash%E9%96%A2%E6%95%B0)で説明されている Geohash アルゴリズムに基づいています．

## このプロジェクトについて

このプロジェクトは，**オブジェクト指向プログラミング（OOP）のサンプル実装**および**Geohash アルゴリズムを理解するための教育ツール**として設計されています．最適化や速度よりも一貫性のある設計とアルゴリズムの透明性を重視しています（とはいえ，この目的を充足した上での可能な限りの高速化を追求していない訳ではありません）．

#### 主な特徴：

- OOP の原則をわかりやすく，直感的に示すクリーンな実装例を提供しています．
- 読みやすさと明確さを重視して，学習者が Geohash アルゴリズムを理解する一助としています．


## Geohash とは？

Geohash
は，地球上の緯度・経度（地理座標）を階層的かつコンパクトな文字列で表現する空間データ構造です．この構造により，地理的な近接性を文字列で簡便に表すことができます．  
Geohash の主な特徴は以下の通りです：

- **再帰的な分割**：Geohash
  は，地球表面を東西・南北方向に再帰的に分割し，細分化された（近似的には長方形としてとらえられる）領域をハッシュ値として符号化します．厳密には，極付近や赤道など一部の地域では形状が不規則になる場合がありますが，この仕組みにより，位置情報の効率的な保存や検索が可能になります．
- **コンパクトな文字列表現**：Geohash 文字列においては，桁数によってエンコード精度が決定されます．一般に 12 桁の Geohash
  は，緯度・経度を数 cm 単位で細かく表現するのに十分な精度を持っています．また，近接する領域や包含する領域との間で類似した文字列となる性質を持っています．
- **データーベースとの相性のよさ**：緯度・経度を直接扱うよりも，Geohash
  エンコードを用いることでデータベース検索が効率化され，用途によっては速度が大幅に向上します．これにより，位置情報を使ったクエリの処理に適したデータ構造となります．

### 精度テーブル

以下の表は，異なる長さの Geohash 文字列に対応するおおよその解像度を示しています：
> **注意**：この表に記載されている解像度は赤道付近でのおおよその値を表しています．緯度が高くなり極に近づくにつれて，地球の曲率の影響で経度方向（東西方向）の解像度が細かくなります．

| 長さ | 解像度（緯度 x 経度）        |
|----|---------------------|
| 1  | ±2500 km x ±5000 km |
| 2  | ±630 km x ±1250 km  |
| 3  | ±78 km x ±156 km    |
| 4  | ±20 km x ±39 km     |
| 5  | ±2.4 km x ±4.9 km   |
| 6  | ±610 m x ±1.2 km    |
| 7  | ±76 m x ±152 m      |
| 8  | ±19 m x ±38 m       |
| 9  | ±2.4 m x ±4.8 m     |
| 10 | ±0.6 m x ±1.2 m     |
| 11 | ±0.07 m x ±0.15 m   |
| 12 | ±0.018 m x ±0.038 m |

ライブラリではデフォルトで精度が 11 に設定されていますが，ユーザーが要件に応じてカスタムの長さを指定することも可能です．

## 機能

- 地理座標を Geohash 文字列にエンコード
- Geohash 文字列を緯度・経度の座標にデコード
- 与えられた Geohash の近接する Geohash を取得
- 処理中に緯度と経度を正規化
- 座標や Geohash 文字列の入力検証を実施
- 緯度と経度の正規化
- 緯度・経度が処理中にどのように正規化されるかを示す明確な例を提供

## 必要要件 (Requirements)

本ライブラリを動作させるために必要なパッケージは以下の通りです：

- **必須**: [`bitarray`](https://pypi.org/project/bitarray/)  
  Geohash のエンコードおよびデコード処理に使用されます．

また，以下は追加の用途のために必要となるオプション要件です：

- **例: ./examples/geohash_precision_test.py を使用する際**: [`matplotlib`](https://pypi.org/project/matplotlib/)  
  グラフや可視化を行うためのパッケージです．

Python バージョン 3.x（3.7+ を推奨）での利用を想定しています．

## インストール

1. **PyPiからインストールする場合：**

GeohashPy は PyPi に公開されており，以下のコマンドで簡単にインストールできます：

```sh
pip install geohash-py
```

このライブラリには，依存ライブラリとして `bitarray` が含まれるため，自動的にインストールされます．

2. **リポジトリをクローンして使用する場合：**

開発目的やソースコードの直接確認をしたい場合は，以下の手順でリポジトリをクローンしてください：

```sh
git clone https://github.com/layla777/geohash_py.git
cd geohash_py
```

3. **サンプルコードを利用する場合：**

`examples/geohash_precision_test.py` を実行するには，別途 `Matplotlib` をインストールしてください：

```sh
pip install matplotlib
```

## 使い方

`Geohash` クラスを使用して geohashをエンコード，デコード，および正規化する方法や，特定の値で初期化する方法，緯度・経度の正規化方法を示します．

### 入力値に関する仕様

#### 緯度と経度

緯度と経度の入力値については，システムが自動で有効な範囲内になるよう調整します．たとえば，緯度が -90° から +90°
の範囲を超えて入力された場合，対応する範囲内に変換されます（例：91° → 89°）．詳細は[技術詳細](#技術詳細)を確認してください．

例：

```python
gh.set_lat_lng(91.0, -200.0)  # 緯度 91.0 → 89.0，経度 -200.0 → 160.0 に変換
print(gh.decode())  # (88.99999938905239, 160.00000052154064)
```

#### Geohash 文字列

Geohash 文字列として不適切な文字列を指定した場合はエラーが発生します．ただし，以下の条件を満たしていれば，通常のアルゴリズムでは生成されないような
geohash 文字列でも指定可能です：

- Geohash 文字列は文字 `{0–9, b–z（i, l, oを除く）}` のみからなる必要があります．
- 最低 1 文字の長さが必須です．

例：

```python
gh.set_geohash('ezs42p')  # 正常
gh.set_geohash('123@abc"')  # エラー: 不正な文字 '@' を含む
gh.set_geohash('')  # エラー: 空の文字列は無効
```

ただし，通常のアルゴリズムでは生成されない形式の文字列については，全て想定どおりに処理されることを保証するものではありません（現在のバージョンでは未検証の部分が残っています）．今後のバージョンでの正式サポート状況についてはドキュメントやリリースノートを参照してください．

## Geohash オブジェクトの初期化方法

Geohash クラスでは，オブジェクトを初期化するための複数の柔軟な方法をサポートしています．以下のファクトリーメソッドでは，どちらを選んでも機能的には同じです．使用者の好みに応じて選択できます．

### **緯度・経度を使用した初期化**

#### `init_with_lat_lng`
緯度・経度を指定して Geohash を生成します．

```python
from geohash_py import Geohash

# 緯度・経度を使用して初期化 (init_with_lat_lng)
lat_lng = [37.7749, -122.4194]  # サンフランシスコ, カリフォルニア州
length = 8
gh = Geohash.init_with_lat_lng(lat_lng=lat_lng, length=length)
print('生成された geohash:', gh.geohash)  # '9q8yyx4'
```

#### `from_lat_lng`
`init_with_lat_lng` と同じ機能を持つメソッドです．命名規則が異なるだけで，動作は完全に同一です．

```python
# 緯度・経度を使用して初期化 (from_lat_lng)
lat_lng = [37.7749, -122.4194]
precision = 8
gh = Geohash.from_lat_lng(lat_lng=lat_lng, precision=precision)
print('生成された geohash:', gh.geohash)  # '9q8yyx4'
```

---

### **Geohash 文字列を使用した初期化**

#### `init_with_geohash`
既存の Geohash 文字列を使用して初期化します．

```python
# Geohash 文字列を使用した初期化 (init_with_geohash)
geohash_str = '9q8yy'
gh = Geohash.init_with_geohash(geohash_str)
print('生成された geohash:', gh.geohash)  # '9q8yy'
```

#### `from_geohash`
`init_with_geohash` と同じ機能を持つメソッドです．

```python
# Geohash 文字列を使用した初期化 (from_geohash)
geohash_str = '9q8yy'
gh = Geohash.from_geohash(geohash_str)
print('生成された geohash:', gh.geohash)  # '9q8yy'
```

---

## `length=` と `precision=` の仕様

Geohash の桁数（精度）を指定する際に使用できる引数として `length` または `precision` のいずれかをサポートしています．どちらも同じ意味を持つため，どちらを選んでも問題ありません．

例：

```python
# length を使用
gh1 = Geohash.init_with_lat_lng(lat_lng=[34.0522, -118.2437], length=6)

# precision を代わりに使用
gh2 = Geohash.init_with_lat_lng(lat_lng=[34.0522, -118.2437], precision=6)

print(gh1.geohash)  # '9q5ct'
print(gh2.geohash)  # '9q5ct'
```

**注意**: `length` と `precision` を同時に指定することはできません．この場合，以下のエラーが発生します．

```python
# エラー例
gh = Geohash.init_with_lat_lng(lat_lng=[34.0522, -118.2437], length=6, precision=6)
```

エラーメッセージ:
geohash_py.geohash_exceptions.GeohashValueError: Both 'length' and 'precision' cannot be provided at the same time.

### 座標のエンコード

既存の Geohash オブジェクトに新しい座標をエンコードできます：

```python
# 既存の Geohash オブジェクトに新しい座標をエンコード
new_lat_lng = [34.0522, -118.2437]  # ロサンゼルス, カリフォルニア州
gh.encode_with_lat_lng(new_lat_lng, length=8)
print('新しい geohash:', gh.geohash)
```

### **geohash のデコード**

- **緯度・経度の区間を取得 (`decode_to_interval`)**  
  Geohash 文字列を緯度・経度の区間（範囲）にデコードする場合は，`decode_to_interval`メソッドを使用します．この区間は，geohash
  文字列が表す領域を示します．

  ```python
  lat_interval, lng_interval = gh.decode_to_interval()
  print(lat_interval)  # (42.60498046875, 42.607421875)
  print(lng_interval)  # (-5.60302734375, -5.6005859375)
  ```

- **緯度・経度を取得 (`decode`)**  
  Geohash 文字列をデコードして緯度・経度を取得する場合は，`decode`メソッドを使用します．このメソッドは，
  `decode_to_interval` で得られた領域の中心点を返します．

  ```python
  lat, lng = gh.decode()
  print(lat)  # 42.605
  print(lng)  # -5.602
  ```

### 隣接する geohash の階層検索と `order` の概要

効率的な空間検索における最適設定の紹介

- `Geohash` オブジェクトを使用して，指定された geohash の隣接する領域を取得できます．
  検索範囲はメソッドの `order` 引数で制御可能です．

#### `order` の意味と隣接領域への影響

- **`order`** は検索範囲の拡張レベルを示します．
    - **小さい値** (例：1〜5) は最も近い隣接を優先し，効率的な探索に適しています．
        - 例：`order=1` で北・南・東・西，斜め方向を含む計8方向の隣接地を取得します．

    - **大きな値** (例：6〜12) はより広い範囲を含む geohash を返しますが，検索対象が急増するため，特に大きな値を選択する場合は検索の計算時間が増加することに注意してください．
    - `order` が 1 増加するごとに，2次元空間上で対象となる領域の数は平方的（例: 8 倍 → 24 倍 → 48 倍）に拡がります．

#### サンプルコード:

以下の例では，`order` の違いによる出力結果の違いを確認できます．

```python
# order=1 の場合 (1層隣接地を取得)
neighbors = gh.neighbors(order=1)
print('隣接する geohash:', neighbors)

# order=3 の場合 (3層範囲で探索)
wide_neighbors = gh.neighbors(order=3)
print('広範囲の geohash:', wide_neighbors)
```

**推奨範囲**：実用的には `order=1〜5` をご利用ください．これは，計算コストと必要な正確さのバランスを取るためです．

## 技術詳細

### 緯度と経度の正規化

- **経度の正規化**：経度の値は，モジュラー演算を使用して-180度から180度の範囲内に収まるよう調整されます．例：
    - 経度が `190` の場合，`-170` に正規化されます．
    - 経度が `-200` の場合，`160` に正規化されます．

- **緯度の正規化**：緯度の値は，-90度から90度の範囲内に収まるよう調整されます．この範囲を超えた値は，境界で「折り返され」，中心に向かって調整されます．例：
    - 緯度が `-95` の場合，`-85` に正規化されます．
    - 緯度が `100` の場合，`80` に正規化されます．

これにより，地球上の地理的座標が現実的で正確な表現となることが保証されます．

---

## ライセンス

このプロジェクトは MIT ライセンスの下でライセンスされています．詳細は [LICENSE](LICENSE) ファイルをご確認ください．

---

## 謝辞

この実装は，[このブログ記事](http://mtcn.ko-me.com/%E9%96%A2%E6%95%B0%E3%80%81%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA/geohash%E9%96%A2%E6%95%B0)
で説明されている Geohash アルゴリズムを参考としています．

問題や提案を追加したりプルリクエストを送ることで，このプロジェクトに気軽に参加してください．．
